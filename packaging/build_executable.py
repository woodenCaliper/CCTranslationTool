"""Utilities for packaging CCTranslationTool as a single Windows executable."""

from __future__ import annotations

import shutil
import subprocess
import sys
from pathlib import Path


REPO_ROOT = Path(__file__).resolve().parents[1]
OUTPUT_DIR = REPO_ROOT / "package"
EXECUTABLE_NAME = "CCTranslationTool.exe"
ICON_SOURCE = REPO_ROOT / "icon" / "CCT_icon.png"
ICON_CONVERTED = REPO_ROOT / "icon" / "CCT_icon.ico"


def _check_platform() -> None:
    """Ensure the script is executed on Windows."""

    if sys.platform != "win32":
        raise SystemExit(
            "PyInstaller can only build a native Windows executable on Windows. "
            "Please run this script from a Windows environment."
        )


def _ensure_pyinstaller() -> None:
    """Validate that PyInstaller is available before attempting the build."""

    try:
        import PyInstaller  # noqa: F401  # type: ignore
    except ModuleNotFoundError as exc:  # pragma: no cover - dependency check
        raise SystemExit(
            "PyInstaller is required. Install it with `pip install pyinstaller`."
        ) from exc


def _prepare_icon() -> Path:
    """Convert the source PNG into an ICO file for PyInstaller."""

    if not ICON_SOURCE.exists():
        raise SystemExit(f"Icon asset not found at {ICON_SOURCE!s}.")

    try:
        from PIL import Image  # type: ignore
    except ModuleNotFoundError as exc:  # pragma: no cover - dependency check
        raise SystemExit(
            "Pillow is required to prepare the application icon. "
            "Install it with `pip install pillow`."
        ) from exc

    ICON_CONVERTED.parent.mkdir(parents=True, exist_ok=True)
    with Image.open(ICON_SOURCE) as image:
        image = image.convert("RGBA")
        width, height = image.size
        max_dim = max(width, height)
        if width != height:
            square = Image.new("RGBA", (max_dim, max_dim), (0, 0, 0, 0))
            offset = ((max_dim - width) // 2, (max_dim - height) // 2)
            square.paste(image, offset)
            image = square

        available_sizes = [
            size for size in (256, 128, 64, 48, 32, 24, 16) if size <= image.size[0]
        ]
        if not available_sizes:
            available_sizes = [image.size[0]]

        icon_sizes = [(size, size) for size in available_sizes]
        image.save(ICON_CONVERTED, format="ICO", sizes=icon_sizes)

    return ICON_CONVERTED


def build() -> Path:
    """Create a one-file executable using PyInstaller.

    Returns the path to the generated executable.
    """

    _check_platform()
    _ensure_pyinstaller()
    icon_path = _prepare_icon()

    command = [
        sys.executable,
        "-m",
        "PyInstaller",
        "--clean",
        "--noconfirm",
        "--noconsole",
        "--onefile",
        "--name",
        EXECUTABLE_NAME.replace(".exe", ""),
        "--icon",
        str(icon_path),
        "--add-data",
        f"{ICON_SOURCE};icon",
        str(REPO_ROOT / "translator_app.py"),
    ]

    subprocess.run(command, check=True, cwd=REPO_ROOT)

    dist_dir = REPO_ROOT / "dist"
    executable_path = dist_dir / EXECUTABLE_NAME
    if not executable_path.exists():
        raise SystemExit(
            "PyInstaller did not produce the expected executable at "
            f"{executable_path!s}."
        )

    OUTPUT_DIR.mkdir(exist_ok=True)
    final_path = OUTPUT_DIR / EXECUTABLE_NAME
    shutil.move(str(executable_path), final_path)

    # Remove temporary build artefacts generated by PyInstaller.
    shutil.rmtree(REPO_ROOT / "build", ignore_errors=True)
    shutil.rmtree(dist_dir, ignore_errors=True)
    spec_file = REPO_ROOT / f"{EXECUTABLE_NAME.replace('.exe', '')}.spec"
    if spec_file.exists():
        spec_file.unlink()

    return final_path


if __name__ == "__main__":  # pragma: no cover - manual execution entrypoint
    path = build()
    print(f"Executable created at {path}")
